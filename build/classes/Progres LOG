

--) we are in the phase to calculate the db necessary components for the competition table attributes calculation
taking in consideration the match in hand.

---) TO calculate the isTopTeam, isP3, isP3Up or p3Down a structure with all the teams and their points is needed.
	  So an addition query and analog data structure is needed at structures. Instead of taking all the 
	  teamtable attributes for all the teams it would be more memory effective to get just teamName and points.
	  

***) we are at the point where we are trying to implement the teamtable attributes calculation when the matches are inserted
	 for the first time and in case of renewal for the next match.
	 These are all untested. 
	 procedure to be tested 
	 						get matches
	 						calculate attributes
	 						set tables ready
	 						store / update to db
	 						
--) A problem we might be having is the empty ht values from competition matches that don't have them.
	Security Measures Required	 
	
	
--) i changed a bit the structure so now we don't have two types of entity classes but one basic that extends another 
	one with the HT attributes. 
	
***) Re-think and Redesign the architecture to keep in ming the continuous/big amount of games per each competition.
	 To skip some calculation for the first 3 weeks of games (like tt, p3 up& down, form) since at the 
	 beginning all the teams are in the same situation.
	 @@ count the matches in & out.
	 ** to init the teamtable attributes with 0 instead of null values when we just got the first data for that
	 	table. (So  when it is a new table)  
	 

---) the structure that keeps matches keeps a Map with competition-<matchesList>. The list is passed to be calculated
	 at every step we check if the teams are in the array if so we get them with their values otherwise we create new ones
	 once the attributes are updated every 4 matches we RECLASSIFY the teams in the tables so that their position is 
	 correct. at the end of the list we store the data to db.
	 
	 
	 **TODO-  implement the order classification table on team-table class.
	 !! sort sort of implemented. (trying)

	 			-------------------------------------------------
	 			-------------------------------------------------------
	 			************************************************
	 			---------------------------------------------------------
	 
	 	 	  
	set up write to file methods for unilang Maps and also for allowed competitionsMap*(this should be in countrycomp class file)
	 
	 * implement a better comparison than simple leveshtain for Strings comprized of more than one word.  				 	  
	 				 	  
	 				 	  
	 				 	  
	 				 	  
	**Find with actions have to go together and coordinate them in strategy pack 				 	  
	 * set CCAS DB to 1 for competitions we are considering				 	  
	
	
	while match scraping we get the teams with the xscorer name and put them on the list. But the teams are going
	to be stored as are the rest of the teams of the from soccerPunter. the teams are converted afterwards to be
	more efficient with database io.  *** (change of plan)
	
	The teams are going to be stored in the TempMatchDatabase as the Rest of the SocerPunter cleaned names.
		The reason for this is that we need a common format for the team names considering that we may be using
		names from other sites for the betting odds.  
	SO : from xscorer get (competition and countries) & compId; fill the tempMatchesList; correlate names & populate 
	Unilang TeamMaps. On the rest "periodic" (add results, odds etc) use unilang conversion for fast team correlation
	
	
	*** Watching term correlation in files some error must be occurring (fixed bug when writing but it writes it twice) even if	
		it is already written in the file	
	HOPEFULLY successful search and correlation for term.  

	** Passing to team search and Finished matches completion {problems with team finding}
	
	Generally working ... ** problem with deleteing data from tempMAtchesDb && 
	*** handle canceled and postponed matches (delete from temp matches but dont store to matches)
	*** TODO clear all the ,aps and lists of data after the periodic function has ended
	 				 	  
	 				 	  
	 				 	  
	 				 	  
	 				 	  
	 				 	  